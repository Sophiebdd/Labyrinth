<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Labyrinthe</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            background-image: url('map.jpg'); /* Image de la carte */
            background-size: cover;
            background-position: center;
        }

        #labyrinthContainer {
            display: none; /* Cacher le labyrinthe au début */
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            height: 400px;
            z-index: 10;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
    </style>
</head>
<body>

<!-- Canvas pour la carte -->
<canvas id="mapCanvas"></canvas>

<!-- Canvas pour le labyrinthe -->
<div id="labyrinthContainer">
    <canvas id="labyrinthCanvas" width="400" height="400"></canvas>
</div>

<script>
    const mapCanvas = document.getElementById("mapCanvas");
    const mapCtx = mapCanvas.getContext("2d");
    const labyrinthCanvas = document.getElementById("labyrinthCanvas");
    const labyrinthCtx = labyrinthCanvas.getContext("2d");

    const mapWidth = window.innerWidth;
    const mapHeight = window.innerHeight;
    mapCanvas.width = mapWidth;
    mapCanvas.height = mapHeight;

    const rows = 23;
    const cols = 23;
    const cellSize = 400 / rows;
    const directions = [{x: 0, y: -1}, {x: 1, y: 0}, {x: 0, y: 1}, {x: -1, y: 0}]; // haut, droite, bas, gauche

    let maze = Array(rows).fill().map(() => Array(cols).fill(1)); // 1 = mur, 0 = chemin
    let visited = Array(rows).fill().map(() => Array(cols).fill(false));

    // Proportions basées sur la taille de la carte (ajuste les positions de façon relative)
    const kaamelott = { x: 1460 / 1920, y: 895 / 1080 }; // Coordonnées relatives
    const labyrintheEntree = { x: 150 / 1920, y: 50 / 1080 }; // Coordonnées relatives

    const buissonImg = new Image();
    buissonImg.src = 'buisson.png'; // Image pour les murs

    let entree = {x: 0, y: 0}; // Coordonnées de l'entrée
    let sortie = {x: 0, y: 0}; // Coordonnées de la sortie
    let treasure = null; // Position du trésor

    // Générer un labyrinthe avec l'algorithme de backtracking
    function generateMaze(x, y) {
        visited[x][y] = true;
        maze[x][y] = 0;

        directions.sort(() => Math.random() - 0.5); // Mélanger les directions

        for (let i = 0; i < directions.length; i++) {
            const dx = directions[i].x;
            const dy = directions[i].y;

            const nx = x + dx * 2;
            const ny = y + dy * 2;

            if (nx > 0 && nx < rows && ny > 0 && ny < cols && !visited[nx][ny]) {
                maze[x + dx][y + dy] = 0; // Casser le mur entre les deux cellules
                generateMaze(nx, ny);
            }
        }
    }

    // Placer l'entrée et la sortie du labyrinthe de manière aléatoire, et dégager autour
    function setRandomEntranceAndExit() {
        // Entrée aléatoire sur le premier rang
        entree.x = 0;
        entree.y = Math.floor(Math.random() * cols);
        maze[entree.x][entree.y] = 0; // Pas de mur à l'entrée

        // Sortie aléatoire sur le dernier rang
        sortie.x = rows - 1;
        sortie.y = Math.floor(Math.random() * cols);
        maze[sortie.x][sortie.y] = 0; // Pas de mur à la sortie

        // Dégager les cases autour de l'entrée
        if (entree.y > 0) maze[entree.x][entree.y - 1] = 0; // Case à gauche
        if (entree.y < cols - 1) maze[entree.x][entree.y + 1] = 0; // Case à droite
        if (entree.x < rows - 1) maze[entree.x + 1][entree.y] = 0; // Case en dessous

        // Dégager les cases autour de la sortie
        if (sortie.y > 0) maze[sortie.x][sortie.y - 1] = 0; // Case à gauche
        if (sortie.y < cols - 1) maze[sortie.x][sortie.y + 1] = 0; // Case à droite
        if (sortie.x > 0) maze[sortie.x - 1][sortie.y] = 0; // Case au dessus
    }

    // Dessiner les points sur la carte
    function drawMapPoints() {
        const kaamelottX = kaamelott.x * mapCanvas.width;
        const kaamelottY = kaamelott.y * mapCanvas.height;
        const labyrintheEntreeX = labyrintheEntree.x * mapCanvas.width;
        const labyrintheEntreeY = labyrintheEntree.y * mapCanvas.height;

        drawPoint(mapCtx, kaamelottX, kaamelottY, 'Kaamelott', 'green');
        drawPoint(mapCtx, labyrintheEntreeX, labyrintheEntreeY, 'Labyrinthe', 'green');
    }

    // Fonction pour dessiner des points
    function drawPoint(ctx, x, y, label, color) {
        ctx.beginPath();
        ctx.arc(x, y, 10, 0, Math.PI * 2, true);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.font = "16px Arial";
        ctx.fillText(label, x + 15, y);
    }

    // Animer l'épée sur la carte
    function animateSwordOnMap(callback, start, end) {
        const path = getPath(start, end);
        let i = 0;

        const swordImg = new Image();
        swordImg.src = 'perso.png'; // Assurez-vous d'avoir cette image
        swordImg.onload = function() {
            const interval = setInterval(() => {
                if (i > 0) {
                    const prev = path[i - 1];
                    mapCtx.clearRect(prev.x - 20, prev.y - 20, 60, 60); // Effacer l'épée précédente
                    drawMapPoints(); // Redessiner les points
                }

                const current = path[i];
                mapCtx.drawImage(swordImg, current.x - 20, current.y - 20, 60, 60); // Dessiner l'épée

                i++;
                if (i >= path.length) {
                    clearInterval(interval);
                    if (callback) callback(); // Une fois arrivé, afficher le labyrinthe
                }
            }, 200); // Vitesse de déplacement
        };
    }

    // Calculer un chemin simple entre deux points (ligne droite)
    function getPath(start, end) {
        const path = [];
        const steps = 20; // Nombre de points intermédiaires

        for (let i = 0; i <= steps; i++) {
            const x = start.x + (end.x - start.x) * (i / steps);
            const y = start.y + (end.y - start.y) * (i / steps);
            path.push({ x, y });
        }
        return path;
    }

    // Placer le trésor dans une cellule aléatoire
    function placeTreasure() {
        let treasureX, treasureY;
        do {
            treasureX = Math.floor(Math.random() * rows);
            treasureY = Math.floor(Math.random() * cols);
        } while (maze[treasureX][treasureY] === 1 || (treasureX === entree.x && treasureY === entree.y) || (treasureX === sortie.x && treasureY === sortie.y)); // Ne placer que dans les chemins, éviter l'entrée et la sortie
        return {x: treasureX, y: treasureY};
    }

    // Trouver le chemin le plus court avec BFS
    function bfs(start, goal) {
        let queue = [{pos: start, path: [start]}];
        let visited = Array(rows).fill().map(() => Array(cols).fill(false));
        visited[start.x][start.y] = true;

        while (queue.length > 0) {
            let {pos, path} = queue.shift();

            if (pos.x === goal.x && pos.y === goal.y) {
                return path;
            }

            for (let d of directions) {
                let newX = pos.x + d.x;
                let newY = pos.y + d.y;

                if (newX >= 0 && newY >= 0 && newX < rows && newY < cols && !visited[newX][newY] && maze[newX][newY] === 0) {
                    visited[newX][newY] = true;
                    queue.push({pos: {x: newX, y: newY}, path: [...path, {x: newX, y: newY}]});
                }
            }
        }
        return null; // Aucun chemin trouvé
    }

    // Dessiner le labyrinthe
    function drawMaze() {
        labyrinthCtx.clearRect(0, 0, labyrinthCanvas.width, labyrinthCanvas.height);

        // Attendre que l'image du buisson soit chargée avant de dessiner le labyrinthe
        buissonImg.onload = function() {
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    if (maze[i][j] === 1) {
                        labyrinthCtx.drawImage(buissonImg, j * cellSize, i * cellSize, cellSize, cellSize);
                    } else {
                        labyrinthCtx.fillStyle = "white";
                        labyrinthCtx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
                    }
                }
            }
        };

        // Si l'image est déjà chargée, dessiner immédiatement
        if (buissonImg.complete) {
            buissonImg.onload();
        }
    }

    // Animer l'épée sur le chemin trouvé dans le labyrinthe
    function animateSwordInMaze(path, callback) {
        let i = 0;
        const swordImg = new Image();
        swordImg.src = 'perso.png';

        swordImg.onload = function() {
            const interval = setInterval(() => {
                if (i > 0) {
                    let prev = path[i - 1];
                    labyrinthCtx.clearRect(prev.y * cellSize, prev.x * cellSize, cellSize, cellSize);
                    labyrinthCtx.fillStyle = "white";
                    labyrinthCtx.fillRect(prev.y * cellSize, prev.x * cellSize, cellSize, cellSize);
                }

                let current = path[i];
                labyrinthCtx.drawImage(swordImg, current.y * cellSize, current.x * cellSize, cellSize, cellSize);

                i++;
                if (i >= path.length) {
                    clearInterval(interval);
                    if (callback) callback();
                }
            }, 200);
        };
    }

    // Animation après avoir trouvé le trésor : sortie du labyrinthe et retour à Kaamelott
    function finishLabyrinth() {
        const pathToExit = bfs({x: treasure.x, y: treasure.y}, {x: sortie.x, y: sortie.y});

        if (pathToExit) {
            animateSwordInMaze(pathToExit, () => {
                // Après avoir atteint la sortie, retourner sur la carte
                document.getElementById('labyrinthContainer').style.display = 'none';

                // Faire le chemin retour sur la carte
                const labyrintheEntreeX = labyrintheEntree.x * mapCanvas.width;
                const labyrintheEntreeY = labyrintheEntree.y * mapCanvas.height;
                const kaamelottX = kaamelott.x * mapCanvas.width;
                const kaamelottY = kaamelott.y * mapCanvas.height;

                animateSwordOnMap(() => {
                    // Retour à Kaamelott terminé
                    console.log('Retour à Kaamelott terminé');
                }, {x: labyrintheEntreeX, y: labyrintheEntreeY}, {x: kaamelottX, y: kaamelottY});
            });
        }
    }

    // Lancer la génération et l'animation
    function startLabyrinth() {
        generateMaze(1, 1);
        setRandomEntranceAndExit(); // Définir l'entrée et la sortie
        drawMaze();

        treasure = placeTreasure();
        const treasureImg = new Image();
        treasureImg.src = 'gem-regular.svg'; // Image du trésor

        treasureImg.onload = function() {
            labyrinthCtx.drawImage(treasureImg, treasure.y * cellSize, treasure.x * cellSize, cellSize, cellSize);
        };

        const path = bfs({x: entree.x, y: entree.y}, treasure); // L'épée commence à l'entrée
        if (path) {
            animateSwordInMaze(path, () => {
                // Supprimer le trésor après l'avoir trouvé
                labyrinthCtx.clearRect(treasure.y * cellSize, treasure.x * cellSize, cellSize, cellSize);
                finishLabyrinth(); // Sortir du labyrinthe et revenir à Kaamelott
            });
        }
    }

    // Animer la carte et afficher le labyrinthe à l'arrivée
    function startAnimation() {
        const kaamelottX = kaamelott.x * mapCanvas.width;
        const kaamelottY = kaamelott.y * mapCanvas.height;
        const labyrintheEntreeX = labyrintheEntree.x * mapCanvas.width;
        const labyrintheEntreeY = labyrintheEntree.y * mapCanvas.height;

        animateSwordOnMap(() => {
            document.getElementById('labyrinthContainer').style.display = 'block';
            startLabyrinth();
        }, {x: kaamelottX, y: kaamelottY}, {x: labyrintheEntreeX, y: labyrintheEntreeY});
    }

    // Redimensionner le canvas et redessiner les points
    window.addEventListener('resize', () => {
        mapCanvas.width = window.innerWidth;
        mapCanvas.height = window.innerHeight;
        drawMapPoints(); // Redessiner les points après redimensionnement
    });

    // Démarrer le jeu
    drawMapPoints();
    startAnimation();

</script>

</body>
</html>
