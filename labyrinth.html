<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Carte et Labyrinthe avec trésor</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            background-image: url('kaamelott.jpg'); /* Image de la carte */
            background-size: cover;
            background-position: center;
        }

        #labyrinthContainer {
            display: none; /* Cacher le labyrinthe au début */
            position: absolute;
            top: 50px;
            left: 50px;
            width: 400px;
            height: 400px;
            border: 5px solid rgb(241, 183, 75);
            z-index: 10;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
    </style>
</head>
<body>

<!-- Canvas pour la carte -->
<canvas id="mapCanvas"></canvas>

<!-- Canvas pour le labyrinthe -->
<div id="labyrinthContainer">
    <canvas id="labyrinthCanvas" width="400" height="400"></canvas>
</div>

<script>
    const mapCanvas = document.getElementById("mapCanvas");
    const mapCtx = mapCanvas.getContext("2d");
    const labyrinthCanvas = document.getElementById("labyrinthCanvas");
    const labyrinthCtx = labyrinthCanvas.getContext("2d");
    
    const mapWidth = window.innerWidth;
    const mapHeight = window.innerHeight;
    mapCanvas.width = mapWidth;
    mapCanvas.height = mapHeight;

    const rows = 23;
    const cols = 23;
    const cellSize = 400 / rows;
    const directions = [{x: 0, y: -1}, {x: 1, y: 0}, {x: 0, y: 1}, {x: -1, y: 0}]; // haut, droite, bas, gauche

    let maze = Array(rows).fill().map(() => Array(cols).fill(1)); // 1 = mur, 0 = chemin
    let visited = Array(rows).fill().map(() => Array(cols).fill(false));

    const kaamelott = { x: 1070, y: 520 };
    const labyrintheEntree = { x: 850, y: 150 };

    // Générer un labyrinthe avec l'algorithme de backtracking
    function generateMaze(x, y) {
        visited[x][y] = true;
        maze[x][y] = 0;

        directions.sort(() => Math.random() - 0.5); // Mélanger les directions

        for (let i = 0; i < directions.length; i++) {
            const dx = directions[i].x;
            const dy = directions[i].y;

            const nx = x + dx * 2;
            const ny = y + dy * 2;

            if (nx > 0 && nx < rows && ny > 0 && ny < cols && !visited[nx][ny]) {
                maze[x + dx][y + dy] = 0; // Casser le mur entre les deux cellules
                generateMaze(nx, ny);
            }
        }
    }

    // Dessiner les points sur la carte
    function drawMapPoints() {
        drawPoint(mapCtx, kaamelott.x, kaamelott.y, 'Kaamelott', 'black');
        drawPoint(mapCtx, labyrintheEntree.x, labyrintheEntree.y, 'Entrée du Labyrinthe', 'green');
    }

    // Fonction pour dessiner des points
    function drawPoint(ctx, x, y, label, color) {
        ctx.beginPath();
        ctx.arc(x, y, 10, 0, Math.PI * 2, true);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.font = "16px Arial";
        ctx.fillText(label, x + 15, y);
    }

    // Animer l'épée sur la carte
    function animateSwordOnMap(callback) {
        const path = getPath(kaamelott, labyrintheEntree);
        let i = 0;

        const swordImg = new Image();
        swordImg.src = 'sword.png'; // Assurez-vous d'avoir cette image
        swordImg.onload = function() {
            const interval = setInterval(() => {
                if (i > 0) {
                    const prev = path[i - 1];
                    mapCtx.clearRect(prev.x - 10, prev.y - 10, 30, 30); // Effacer l'épée précédente
                    drawMapPoints(); // Redessiner les points
                }

                const current = path[i];
                mapCtx.drawImage(swordImg, current.x - 10, current.y - 10, 20, 20); // Dessiner l'épée

                i++;
                if (i >= path.length) {
                    clearInterval(interval);
                    if (callback) callback(); // Une fois arrivé, afficher le labyrinthe
                }
            }, 200); // Vitesse de déplacement
        };
    }

    // Calculer un chemin simple entre deux points (ligne droite)
    function getPath(start, end) {
        const path = [];
        const steps = 20; // Nombre de points intermédiaires

        for (let i = 0; i <= steps; i++) {
            const x = start.x + (end.x - start.x) * (i / steps);
            const y = start.y + (end.y - start.y) * (i / steps);
            path.push({ x, y });
        }
        return path;
    }

    // Placer le trésor dans une cellule aléatoire
    function placeTreasure() {
        let treasureX, treasureY;
        do {
            treasureX = Math.floor(Math.random() * rows);
            treasureY = Math.floor(Math.random() * cols);
        } while (maze[treasureX][treasureY] === 1); // Ne placer que dans les chemins
        return {x: treasureX, y: treasureY};
    }

    // Trouver le chemin le plus court avec BFS
    function bfs(start, goal) {
        let queue = [{pos: start, path: [start]}];
        let visited = Array(rows).fill().map(() => Array(cols).fill(false));
        visited[start.x][start.y] = true;

        while (queue.length > 0) {
            let {pos, path} = queue.shift();

            if (pos.x === goal.x && pos.y === goal.y) {
                return path;
            }

            for (let d of directions) {
                let newX = pos.x + d.x;
                let newY = pos.y + d.y;

                if (newX >= 0 && newY >= 0 && newX < rows && newY < cols && !visited[newX][newY] && maze[newX][newY] === 0) {
                    visited[newX][newY] = true;
                    queue.push({pos: {x: newX, y: newY}, path: [...path, {x: newX, y: newY}]});
                }
            }
        }
        return null; // Aucun chemin trouvé
    }

    // Dessiner le labyrinthe
    function drawMaze() {
        labyrinthCtx.clearRect(0, 0, labyrinthCanvas.width, labyrinthCanvas.height);
        for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) {
                labyrinthCtx.fillStyle = maze[i][j] === 1 ? "green" : "white";
                labyrinthCtx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
            }
        }
    }

    // Animer l'épée sur le chemin trouvé dans le labyrinthe
    function animateSwordInMaze(path) {
        let i = 0;
        const swordImg = new Image();
        swordImg.src = 'sword.png';

        swordImg.onload = function() {
            const interval = setInterval(() => {
                if (i > 0) {
                    let prev = path[i - 1];
                    labyrinthCtx.clearRect(prev.y * cellSize, prev.x * cellSize, cellSize, cellSize);
                    labyrinthCtx.fillStyle = "white";
                    labyrinthCtx.fillRect(prev.y * cellSize, prev.x * cellSize, cellSize, cellSize);
                }

                let current = path[i];
                labyrinthCtx.drawImage(swordImg, current.y * cellSize, current.x * cellSize, cellSize, cellSize);

                i++;
                if (i >= path.length) clearInterval(interval);
            }, 200);
        };
    }

    // Lancer la génération et l'animation
    function startLabyrinth() {
        generateMaze(1, 1);
        drawMaze();

        const treasure = placeTreasure();
        const treasureImg = new Image();
        treasureImg.src = 'gem-regular.svg'; // Assurez-vous d'avoir cette image

        treasureImg.onload = function() {
            labyrinthCtx.drawImage(treasureImg, treasure.y * cellSize, treasure.x * cellSize, cellSize, cellSize);
        };

        const path = bfs({x: 1, y: 1}, treasure);
        if (path) animateSwordInMaze(path);
    }

    // Animer la carte et afficher le labyrinthe à l'arrivée
    function startAnimation() {
        animateSwordOnMap(() => {
            document.getElementById('labyrinthContainer').style.display = 'block';
            startLabyrinth();
        });
    }

    // Démarrer le jeu
    drawMapPoints();
    startAnimation();

</script>

</body>
</html>
