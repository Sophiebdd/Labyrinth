<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Labyrinthe avec Entrée et Sortie</title>
    <style>
        canvas {
            border: 1px solid white;
            position: relative;
        }

        #container {
            position: relative;
            width: 500px;
            height: 500px;
        }
    </style>
</head>
<body style="background-image: url('kaamelott.jpg'); background-size: cover; background-position: center; background-repeat: no-repeat; height: 100vh; margin: 0;">


<div id="container">
    <canvas id="canvas" width="500" height="500"></canvas>
</div>

<script>
    var canvas = document.getElementById("canvas");
    var context = canvas.getContext("2d");
    var w = canvas.width;
    var h = canvas.height; 
    var delimiter = 23; // Taille du labyrinthe (20 colonnes)
    var size = w / delimiter;

    // Directions (haut, bas, gauche, droite)
    var directions = [
        { x: -1, y: 0 },  // Haut
        { x: 1, y: 0 },   // Bas
        { x: 0, y: -1 },  // Gauche
        { x: 0, y: 1 }    // Droite
    ];

    // Génération du labyrinthe avec des bords solides
    function generateMaze(width, height) {
        let maze = Array(height).fill().map(() => Array(width).fill(1)); // Rempli avec des murs (1)

        // Fonction pour vérifier si une cellule est dans les limites intérieures
        function isInBounds(x, y) {
            return x > 0 && x < height - 1 && y > 0 && y < width - 1;
        }

        // Commencer avec une cellule aléatoire dans les limites intérieures
        let startX = Math.floor(Math.random() * (height - 2)) + 1;
        let startY = Math.floor(Math.random() * (width - 2)) + 1;
        maze[startX][startY] = 0; // Démarre avec un chemin (0)

        let walls = [];
        for (let dir of directions) {
            let newX = startX + dir.x;
            let newY = startY + dir.y;
            if (isInBounds(newX, newY)) {
                walls.push({ x: newX, y: newY, dir });
            }
        }

        // Étendre les chemins
        while (walls.length > 0) {
            let wallIndex = Math.floor(Math.random() * walls.length);
            let wall = walls[wallIndex];
            walls.splice(wallIndex, 1); // Retirer le mur actuel de la liste

            let nx = wall.x + wall.dir.x;
            let ny = wall.y + wall.dir.y;

            // Vérifier si la nouvelle position est dans les limites intérieures et non encore visitée
            if (isInBounds(nx, ny) && maze[nx][ny] === 1) {
                maze[wall.x][wall.y] = 0;
                maze[nx][ny] = 0; // Créer un chemin

                // Ajouter les nouveaux murs autour de la cellule ouverte
                for (let dir of directions) {
                    let newWallX = nx + dir.x;
                    let newWallY = ny + dir.y;
                    if (isInBounds(newWallX, newWallY) && maze[newWallX][newWallY] === 1) {
                        walls.push({ x: newWallX, y: newWallY, dir });
                    }
                }
            }
        }

        return maze;
    }

    // Ajouter des bords solides tout autour du labyrinthe
    function addBorders(maze) {
        let height = maze.length;
        let width = maze[0].length;

        for (let i = 0; i < height; i++) {
            maze[i][0] = 1; // Bord gauche
            maze[i][width - 1] = 1; // Bord droit
        }
        for (let j = 0; j < width; j++) {
            maze[0][j] = 1; // Bord haut
            maze[height - 1][j] = 1; // Bord bas
        }
    }

    // Placer une entrée et une sortie aléatoire sur les bords du labyrinthe
    function placeEntryAndExit(maze) {
        let height = maze.length;
        let width = maze[0].length;

        // Entrée
        let entryEdge = Math.floor(Math.random() * 4);  // Choisir un bord aléatoire pour l'entrée
        let entry = placeOnEdge(entryEdge, height, width, maze);
        
        // Sortie sur un autre bord
        let exitEdge;
        do {
            exitEdge = Math.floor(Math.random() * 4);
        } while (exitEdge === entryEdge);  // S'assurer que l'entrée et la sortie ne sont pas sur le même bord

        let exit = placeOnEdge(exitEdge, height, width, maze);

        return { entry, exit };
    }

    // Placer un point d'entrée ou de sortie sur un bord
    function placeOnEdge(edge, height, width, maze) {
        let pos;
        switch (edge) {
            case 0: // Bord haut
                pos = { x: 0, y: Math.floor(Math.random() * (width - 2)) + 1 };
                maze[1][pos.y] = 0; // Ouvrir juste en dessous pour avoir un passage
                break;
            case 1: // Bord bas
                pos = { x: height - 1, y: Math.floor(Math.random() * (width - 2)) + 1 };
                maze[height - 2][pos.y] = 0; // Ouvrir juste au-dessus pour avoir un passage
                break;
            case 2: // Bord gauche
                pos = { x: Math.floor(Math.random() * (height - 2)) + 1, y: 0 };
                maze[pos.x][1] = 0; // Ouvrir juste à droite pour avoir un passage
                break;
            case 3: // Bord droit
                pos = { x: Math.floor(Math.random() * (height - 2)) + 1, y: width - 1 };
                maze[pos.x][width - 2] = 0; // Ouvrir juste à gauche pour avoir un passage
                break;
        }
        return pos;
    }

    // Fonction pour dessiner le labyrinthe
    function drawMaze(maze) {
        for (let i = 0; i < maze.length; i++) {
            for (let j = 0; j < maze[i].length; j++) {
                rect(j * size, i * size, size, size, maze[i][j] === 1 ? "green" : "white");
            }
        }
    }

    // Fonction pour dessiner un rectangle
    function rect(x, y, w, h, color) {
        context.fillStyle = color;
        context.fillRect(x, y, w, h);
    }

    // Générer une position aléatoire dans le labyrinthe
    function randomPosition(maze) {
        let x, y;
        do {
            x = Math.floor(Math.random() * maze.length);
            y = Math.floor(Math.random() * maze[0].length);
        } while (maze[x][y] !== 0); // Trouver une position dans un espace vide
        return { x: x, y: y };
    }

    // Algorithme BFS pour trouver le chemin
    function bfs(maze, start, goal) {
        let queue = [{ pos: start, path: [start] }];
        let visited = Array(maze.length).fill().map(() => Array(maze[0].length).fill(false));
        visited[start.x][start.y] = true;

        while (queue.length > 0) {
            let { pos, path } = queue.shift();

            // Si le but (trésor) est atteint
            if (pos.x === goal.x && pos.y === goal.y) {
                return path;
            }

            // Explore les voisins
            for (let dir of directions) {
                let newX = pos.x + dir.x;
                let newY = pos.y + dir.y;

                // Vérifier les limites et si la case est visitable
                if (newX >= 0 && newX < maze.length && newY >= 0 && newY < maze[0].length &&
                    maze[newX][newY] === 0 && !visited[newX][newY]) {
                    
                    visited[newX][newY] = true;
                    queue.push({ pos: { x: newX, y: newY }, path: [...path, { x: newX, y: newY }] });
                }
            }
        }
        return null; // Si aucun chemin trouvé
    }

    // Fonction pour animer le chemin avec une image (ex: sword.png)
    function animateSword(path) {
        let i = 0;
        let interval = setInterval(() => {
            if (i > 0) {
                let prevPos = path[i - 1];
                rect(prevPos.y * size, prevPos.x * size, size, size, "white"); // Réinitialiser la case précédente
            }

            let currentPos = path[i];
            context.drawImage(swordImg, currentPos.y * size, currentPos.x * size, size * 0.8, size * 0.8); // Dessiner l'image à la nouvelle position

            i++;
            if (i >= path.length) {
                clearInterval(interval); // Arrêter l'animation une fois terminé
            }
        }, 200); // Déplacement toutes les 200ms
    }

    // Charger l'image de l'épée
    var swordImg = new Image();
    swordImg.src = 'sword.png'; // Chemin vers votre fichier sword.png

    // Générer le labyrinthe et dessiner
    var maze = generateMaze(delimiter, delimiter);
    addBorders(maze);  // Ajout des bords après génération du labyrinthe
    drawMaze(maze);

    // Placer une entrée et une sortie
    var { entry, exit } = placeEntryAndExit(maze);

    // Choisir une position aléatoire pour le trésor
    var treasurePosition = randomPosition(maze);

    // Dessiner le trésor
    var treasureImg = new Image();
    treasureImg.src = 'gem-regular.svg'; // Chemin vers votre image SVG du trésor
    treasureImg.onload = function() {
        context.drawImage(treasureImg, treasurePosition.y * size, treasurePosition.x * size, size * 0.8, size * 0.8);
    };

    // Trouver le chemin avec BFS entre l'entrée et la sortie (ou le trésor)
    var pathToTreasure = bfs(maze, entry, treasurePosition);

    // Si un chemin est trouvé, animer l'épée
    swordImg.onload = function() {
        if (pathToTreasure) {
            animateSword(pathToTreasure);
        } else {
            console.log("Aucun chemin trouvé vers le trésor.");
        }
    };

</script>

</body>
</html>
